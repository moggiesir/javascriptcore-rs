// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::CheckSyntaxMode;
use crate::CheckSyntaxResult;
use crate::Exception;
use crate::Value;
use crate::VirtualMachine;
use glib::object::IsA;
use glib::translate::*;
use javascriptcore_sys;
use std::boxed::Box as Box_;
use std::fmt;
use std::ptr;

glib_wrapper! {
    pub struct Context(Object<javascriptcore_sys::JSCContext, javascriptcore_sys::JSCContextClass, ContextClass>);

    match fn {
        get_type => || javascriptcore_sys::jsc_context_get_type(),
    }
}

impl Context {
    pub fn new() -> Context {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_new())
        }
    }

    pub fn new_with_virtual_machine<P: IsA<VirtualMachine>>(vm: &P) -> Context {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_new_with_virtual_machine(vm.as_ref().to_glib_none().0))
        }
    }

    pub fn get_current() -> Option<Context> {
        assert_initialized_main_thread!();
        unsafe {
            from_glib_none(javascriptcore_sys::jsc_context_get_current())
        }
    }
}

impl Default for Context {
    fn default() -> Self {
        Self::new()
    }
}

pub const NONE_CONTEXT: Option<&Context> = None;

pub trait ContextExt: 'static {
    fn check_syntax(&self, code: &str, mode: CheckSyntaxMode, uri: &str, line_number: u32) -> (CheckSyntaxResult, Exception);

    fn clear_exception(&self);

    fn evaluate(&self, code: &str) -> Option<Value>;

    fn evaluate_with_source_uri(&self, code: &str, uri: &str, line_number: u32) -> Option<Value>;

    fn get_exception(&self) -> Option<Exception>;

    fn get_global_object(&self) -> Option<Value>;

    fn get_value(&self, name: &str) -> Option<Value>;

    fn get_virtual_machine(&self) -> Option<VirtualMachine>;

    fn pop_exception_handler(&self);

    fn push_exception_handler<P: Fn(&Context, &Exception) + 'static>(&self, handler: P);

    fn set_value<P: IsA<Value>>(&self, name: &str, value: &P);

    fn throw(&self, error_message: &str);

    fn throw_exception<P: IsA<Exception>>(&self, exception: &P);

    fn throw_with_name(&self, error_name: &str, error_message: &str);
}

impl<O: IsA<Context>> ContextExt for O {
    fn check_syntax(&self, code: &str, mode: CheckSyntaxMode, uri: &str, line_number: u32) -> (CheckSyntaxResult, Exception) {
        let length = code.len() as isize;
        unsafe {
            let mut exception = ptr::null_mut();
            let ret = from_glib(javascriptcore_sys::jsc_context_check_syntax(self.as_ref().to_glib_none().0, code.to_glib_none().0, length, mode.to_glib(), uri.to_glib_none().0, line_number, &mut exception));
            (ret, from_glib_full(exception))
        }
    }

    fn clear_exception(&self) {
        unsafe {
            javascriptcore_sys::jsc_context_clear_exception(self.as_ref().to_glib_none().0);
        }
    }

    fn evaluate(&self, code: &str) -> Option<Value> {
        let length = code.len() as isize;
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_evaluate(self.as_ref().to_glib_none().0, code.to_glib_none().0, length))
        }
    }

    fn evaluate_with_source_uri(&self, code: &str, uri: &str, line_number: u32) -> Option<Value> {
        let length = code.len() as isize;
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_evaluate_with_source_uri(self.as_ref().to_glib_none().0, code.to_glib_none().0, length, uri.to_glib_none().0, line_number))
        }
    }

    fn get_exception(&self) -> Option<Exception> {
        unsafe {
            from_glib_none(javascriptcore_sys::jsc_context_get_exception(self.as_ref().to_glib_none().0))
        }
    }

    fn get_global_object(&self) -> Option<Value> {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_get_global_object(self.as_ref().to_glib_none().0))
        }
    }

    fn get_value(&self, name: &str) -> Option<Value> {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_context_get_value(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn get_virtual_machine(&self) -> Option<VirtualMachine> {
        unsafe {
            from_glib_none(javascriptcore_sys::jsc_context_get_virtual_machine(self.as_ref().to_glib_none().0))
        }
    }

    fn pop_exception_handler(&self) {
        unsafe {
            javascriptcore_sys::jsc_context_pop_exception_handler(self.as_ref().to_glib_none().0);
        }
    }

    fn push_exception_handler<P: Fn(&Context, &Exception) + 'static>(&self, handler: P) {
        let handler_data: Box_<P> = Box::new(handler);
        unsafe extern "C" fn handler_func<P: Fn(&Context, &Exception) + 'static>(context: *mut javascriptcore_sys::JSCContext, exception: *mut javascriptcore_sys::JSCException, user_data: glib_sys::gpointer) {
            let context = from_glib_borrow(context);
            let exception = from_glib_borrow(exception);
            let callback: &P = &*(user_data as *mut _);
            (*callback)(&context, &exception);
        }
        let handler = Some(handler_func::<P> as _);
        unsafe extern "C" fn destroy_notify_func<P: Fn(&Context, &Exception) + 'static>(data: glib_sys::gpointer) {
            let _callback: Box_<P> = Box_::from_raw(data as *mut _);
        }
        let destroy_call3 = Some(destroy_notify_func::<P> as _);
        let super_callback0: Box_<P> = handler_data;
        unsafe {
            javascriptcore_sys::jsc_context_push_exception_handler(self.as_ref().to_glib_none().0, handler, Box::into_raw(super_callback0) as *mut _, destroy_call3);
        }
    }

    fn set_value<P: IsA<Value>>(&self, name: &str, value: &P) {
        unsafe {
            javascriptcore_sys::jsc_context_set_value(self.as_ref().to_glib_none().0, name.to_glib_none().0, value.as_ref().to_glib_none().0);
        }
    }

    fn throw(&self, error_message: &str) {
        unsafe {
            javascriptcore_sys::jsc_context_throw(self.as_ref().to_glib_none().0, error_message.to_glib_none().0);
        }
    }

    fn throw_exception<P: IsA<Exception>>(&self, exception: &P) {
        unsafe {
            javascriptcore_sys::jsc_context_throw_exception(self.as_ref().to_glib_none().0, exception.as_ref().to_glib_none().0);
        }
    }

    fn throw_with_name(&self, error_name: &str, error_message: &str) {
        unsafe {
            javascriptcore_sys::jsc_context_throw_with_name(self.as_ref().to_glib_none().0, error_name.to_glib_none().0, error_message.to_glib_none().0);
        }
    }
}

impl fmt::Display for Context {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Context")
    }
}
