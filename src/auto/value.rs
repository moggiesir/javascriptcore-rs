// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use crate::Context;
use crate::ValuePropertyFlags;
use glib;
use glib::GString;
use glib::object::IsA;
use glib::translate::*;
use javascriptcore_sys;
use std::fmt;

glib_wrapper! {
    pub struct Value(Object<javascriptcore_sys::JSCValue, javascriptcore_sys::JSCValueClass, ValueClass>);

    match fn {
        get_type => || javascriptcore_sys::jsc_value_get_type(),
    }
}

impl Value {
    pub fn new_array_from_strv<P: IsA<Context>>(context: &P, strv: &[&str]) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_array_from_strv(context.as_ref().to_glib_none().0, strv.to_glib_none().0))
        }
    }

    pub fn new_boolean<P: IsA<Context>>(context: &P, value: bool) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_boolean(context.as_ref().to_glib_none().0, value.to_glib()))
        }
    }

    pub fn new_null<P: IsA<Context>>(context: &P) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_null(context.as_ref().to_glib_none().0))
        }
    }

    pub fn new_number<P: IsA<Context>>(context: &P, number: f64) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_number(context.as_ref().to_glib_none().0, number))
        }
    }

    pub fn new_string<P: IsA<Context>>(context: &P, string: Option<&str>) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_string(context.as_ref().to_glib_none().0, string.to_glib_none().0))
        }
    }

    pub fn new_string_from_bytes<P: IsA<Context>>(context: &P, bytes: Option<&glib::Bytes>) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_string_from_bytes(context.as_ref().to_glib_none().0, bytes.to_glib_none().0))
        }
    }

    pub fn new_undefined<P: IsA<Context>>(context: &P) -> Value {
        skip_assert_initialized!();
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_new_undefined(context.as_ref().to_glib_none().0))
        }
    }
}

pub const NONE_VALUE: Option<&Value> = None;

pub trait ValueExt: 'static {
    fn constructor_callv(&self, parameters: &[Value]) -> Option<Value>;

    fn function_callv(&self, parameters: &[Value]) -> Option<Value>;

    fn get_context(&self) -> Option<Context>;

    fn is_array(&self) -> bool;

    fn is_boolean(&self) -> bool;

    fn is_constructor(&self) -> bool;

    fn is_function(&self) -> bool;

    fn is_null(&self) -> bool;

    fn is_number(&self) -> bool;

    fn is_object(&self) -> bool;

    fn is_string(&self) -> bool;

    fn is_undefined(&self) -> bool;

    fn object_define_property_data<P: IsA<Value>>(&self, property_name: &str, flags: ValuePropertyFlags, property_value: Option<&P>);

    fn object_delete_property(&self, name: &str) -> bool;

    fn object_enumerate_properties(&self) -> Vec<GString>;

    fn object_get_property(&self, name: &str) -> Option<Value>;

    fn object_get_property_at_index(&self, index: u32) -> Option<Value>;

    fn object_has_property(&self, name: &str) -> bool;

    fn object_invoke_methodv(&self, name: &str, parameters: &[Value]) -> Option<Value>;

    fn object_is_instance_of(&self, name: &str) -> bool;

    fn object_set_property<P: IsA<Value>>(&self, name: &str, property: &P);

    fn object_set_property_at_index<P: IsA<Value>>(&self, index: u32, property: &P);

    fn to_boolean(&self) -> bool;

    fn to_double(&self) -> f64;

    fn to_int32(&self) -> i32;

    fn to_string(&self) -> GString;

    fn to_string_as_bytes(&self) -> Option<glib::Bytes>;
}

impl<O: IsA<Value>> ValueExt for O {
    fn constructor_callv(&self, parameters: &[Value]) -> Option<Value> {
        let n_parameters = parameters.len() as u32;
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_constructor_callv(self.as_ref().to_glib_none().0, n_parameters, parameters.to_glib_none().0))
        }
    }

    fn function_callv(&self, parameters: &[Value]) -> Option<Value> {
        let n_parameters = parameters.len() as u32;
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_function_callv(self.as_ref().to_glib_none().0, n_parameters, parameters.to_glib_none().0))
        }
    }

    fn get_context(&self) -> Option<Context> {
        unsafe {
            from_glib_none(javascriptcore_sys::jsc_value_get_context(self.as_ref().to_glib_none().0))
        }
    }

    fn is_array(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_array(self.as_ref().to_glib_none().0))
        }
    }

    fn is_boolean(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_boolean(self.as_ref().to_glib_none().0))
        }
    }

    fn is_constructor(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_constructor(self.as_ref().to_glib_none().0))
        }
    }

    fn is_function(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_function(self.as_ref().to_glib_none().0))
        }
    }

    fn is_null(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_null(self.as_ref().to_glib_none().0))
        }
    }

    fn is_number(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_number(self.as_ref().to_glib_none().0))
        }
    }

    fn is_object(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_object(self.as_ref().to_glib_none().0))
        }
    }

    fn is_string(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_string(self.as_ref().to_glib_none().0))
        }
    }

    fn is_undefined(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_is_undefined(self.as_ref().to_glib_none().0))
        }
    }

    fn object_define_property_data<P: IsA<Value>>(&self, property_name: &str, flags: ValuePropertyFlags, property_value: Option<&P>) {
        unsafe {
            javascriptcore_sys::jsc_value_object_define_property_data(self.as_ref().to_glib_none().0, property_name.to_glib_none().0, flags.to_glib(), property_value.map(|p| p.as_ref()).to_glib_none().0);
        }
    }

    fn object_delete_property(&self, name: &str) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_object_delete_property(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn object_enumerate_properties(&self) -> Vec<GString> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(javascriptcore_sys::jsc_value_object_enumerate_properties(self.as_ref().to_glib_none().0))
        }
    }

    fn object_get_property(&self, name: &str) -> Option<Value> {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_object_get_property(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn object_get_property_at_index(&self, index: u32) -> Option<Value> {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_object_get_property_at_index(self.as_ref().to_glib_none().0, index))
        }
    }

    fn object_has_property(&self, name: &str) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_object_has_property(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn object_invoke_methodv(&self, name: &str, parameters: &[Value]) -> Option<Value> {
        let n_parameters = parameters.len() as u32;
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_object_invoke_methodv(self.as_ref().to_glib_none().0, name.to_glib_none().0, n_parameters, parameters.to_glib_none().0))
        }
    }

    fn object_is_instance_of(&self, name: &str) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_object_is_instance_of(self.as_ref().to_glib_none().0, name.to_glib_none().0))
        }
    }

    fn object_set_property<P: IsA<Value>>(&self, name: &str, property: &P) {
        unsafe {
            javascriptcore_sys::jsc_value_object_set_property(self.as_ref().to_glib_none().0, name.to_glib_none().0, property.as_ref().to_glib_none().0);
        }
    }

    fn object_set_property_at_index<P: IsA<Value>>(&self, index: u32, property: &P) {
        unsafe {
            javascriptcore_sys::jsc_value_object_set_property_at_index(self.as_ref().to_glib_none().0, index, property.as_ref().to_glib_none().0);
        }
    }

    fn to_boolean(&self) -> bool {
        unsafe {
            from_glib(javascriptcore_sys::jsc_value_to_boolean(self.as_ref().to_glib_none().0))
        }
    }

    fn to_double(&self) -> f64 {
        unsafe {
            javascriptcore_sys::jsc_value_to_double(self.as_ref().to_glib_none().0)
        }
    }

    fn to_int32(&self) -> i32 {
        unsafe {
            javascriptcore_sys::jsc_value_to_int32(self.as_ref().to_glib_none().0)
        }
    }

    fn to_string(&self) -> GString {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_to_string(self.as_ref().to_glib_none().0))
        }
    }

    fn to_string_as_bytes(&self) -> Option<glib::Bytes> {
        unsafe {
            from_glib_full(javascriptcore_sys::jsc_value_to_string_as_bytes(self.as_ref().to_glib_none().0))
        }
    }
}

impl fmt::Display for Value {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Value")
    }
}
