// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::translate::*;
use javascriptcore_sys;
use std::fmt;

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CheckSyntaxMode {
    Script,
    Module,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CheckSyntaxMode {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CheckSyntaxMode::{}", match *self {
            CheckSyntaxMode::Script => "Script",
            CheckSyntaxMode::Module => "Module",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CheckSyntaxMode {
    type GlibType = javascriptcore_sys::JSCCheckSyntaxMode;

    fn to_glib(&self) -> javascriptcore_sys::JSCCheckSyntaxMode {
        match *self {
            CheckSyntaxMode::Script => javascriptcore_sys::JSC_CHECK_SYNTAX_MODE_SCRIPT,
            CheckSyntaxMode::Module => javascriptcore_sys::JSC_CHECK_SYNTAX_MODE_MODULE,
            CheckSyntaxMode::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<javascriptcore_sys::JSCCheckSyntaxMode> for CheckSyntaxMode {
    fn from_glib(value: javascriptcore_sys::JSCCheckSyntaxMode) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CheckSyntaxMode::Script,
            1 => CheckSyntaxMode::Module,
            value => CheckSyntaxMode::__Unknown(value),
        }
    }
}

#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum CheckSyntaxResult {
    Success,
    RecoverableError,
    IrrecoverableError,
    UnterminatedLiteralError,
    OutOfMemoryError,
    StackOverflowError,
    #[doc(hidden)]
    __Unknown(i32),
}

impl fmt::Display for CheckSyntaxResult {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "CheckSyntaxResult::{}", match *self {
            CheckSyntaxResult::Success => "Success",
            CheckSyntaxResult::RecoverableError => "RecoverableError",
            CheckSyntaxResult::IrrecoverableError => "IrrecoverableError",
            CheckSyntaxResult::UnterminatedLiteralError => "UnterminatedLiteralError",
            CheckSyntaxResult::OutOfMemoryError => "OutOfMemoryError",
            CheckSyntaxResult::StackOverflowError => "StackOverflowError",
            _ => "Unknown",
        })
    }
}

#[doc(hidden)]
impl ToGlib for CheckSyntaxResult {
    type GlibType = javascriptcore_sys::JSCCheckSyntaxResult;

    fn to_glib(&self) -> javascriptcore_sys::JSCCheckSyntaxResult {
        match *self {
            CheckSyntaxResult::Success => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_SUCCESS,
            CheckSyntaxResult::RecoverableError => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_RECOVERABLE_ERROR,
            CheckSyntaxResult::IrrecoverableError => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_IRRECOVERABLE_ERROR,
            CheckSyntaxResult::UnterminatedLiteralError => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_UNTERMINATED_LITERAL_ERROR,
            CheckSyntaxResult::OutOfMemoryError => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_OUT_OF_MEMORY_ERROR,
            CheckSyntaxResult::StackOverflowError => javascriptcore_sys::JSC_CHECK_SYNTAX_RESULT_STACK_OVERFLOW_ERROR,
            CheckSyntaxResult::__Unknown(value) => value
        }
    }
}

#[doc(hidden)]
impl FromGlib<javascriptcore_sys::JSCCheckSyntaxResult> for CheckSyntaxResult {
    fn from_glib(value: javascriptcore_sys::JSCCheckSyntaxResult) -> Self {
        skip_assert_initialized!();
        match value {
            0 => CheckSyntaxResult::Success,
            1 => CheckSyntaxResult::RecoverableError,
            2 => CheckSyntaxResult::IrrecoverableError,
            3 => CheckSyntaxResult::UnterminatedLiteralError,
            4 => CheckSyntaxResult::OutOfMemoryError,
            5 => CheckSyntaxResult::StackOverflowError,
            value => CheckSyntaxResult::__Unknown(value),
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[derive(Debug, Eq, PartialEq, Ord, PartialOrd, Hash)]
#[derive(Clone, Copy)]
pub enum OptionType {
    Boolean,
    Int,
    Uint,
    Size,
    Double,
    String,
    RangeString,
    #[doc(hidden)]
    __Unknown(i32),
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
impl fmt::Display for OptionType {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "OptionType::{}", match *self {
            OptionType::Boolean => "Boolean",
            OptionType::Int => "Int",
            OptionType::Uint => "Uint",
            OptionType::Size => "Size",
            OptionType::Double => "Double",
            OptionType::String => "String",
            OptionType::RangeString => "RangeString",
            _ => "Unknown",
        })
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[doc(hidden)]
impl ToGlib for OptionType {
    type GlibType = javascriptcore_sys::JSCOptionType;

    fn to_glib(&self) -> javascriptcore_sys::JSCOptionType {
        match *self {
            OptionType::Boolean => javascriptcore_sys::JSC_OPTION_BOOLEAN,
            OptionType::Int => javascriptcore_sys::JSC_OPTION_INT,
            OptionType::Uint => javascriptcore_sys::JSC_OPTION_UINT,
            OptionType::Size => javascriptcore_sys::JSC_OPTION_SIZE,
            OptionType::Double => javascriptcore_sys::JSC_OPTION_DOUBLE,
            OptionType::String => javascriptcore_sys::JSC_OPTION_STRING,
            OptionType::RangeString => javascriptcore_sys::JSC_OPTION_RANGE_STRING,
            OptionType::__Unknown(value) => value
        }
    }
}

#[cfg(any(feature = "v2_24", feature = "dox"))]
#[doc(hidden)]
impl FromGlib<javascriptcore_sys::JSCOptionType> for OptionType {
    fn from_glib(value: javascriptcore_sys::JSCOptionType) -> Self {
        skip_assert_initialized!();
        match value {
            0 => OptionType::Boolean,
            1 => OptionType::Int,
            2 => OptionType::Uint,
            3 => OptionType::Size,
            4 => OptionType::Double,
            5 => OptionType::String,
            6 => OptionType::RangeString,
            value => OptionType::__Unknown(value),
        }
    }
}

