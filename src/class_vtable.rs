// This file was generated by gir (https://github.com/gtk-rs/gir)
// from gir-files (https://github.com/gtk-rs/gir-files)
// DO NOT EDIT

use glib::object::IsA;
use glib::translate::*;
use glib::GString;
use glib::StaticType;
use glib::Value as GValue;
use gobject_sys;
use javascriptcore_sys::{JSCClass, JSCClassVTable, JSCContext, JSCValue};
use std::fmt;
use Class;
use Context;
use NativeClass;
use Value;

pub trait AsNativeVTable<T> {
    unsafe fn as_vtable(&self) -> JSCClassVTable;
}

impl<T> AsNativeVTable<T> for JSCClassVTable {
    unsafe fn as_vtable(&self) -> JSCClassVTable {
        self.clone()
    }
}

pub struct ClassVTable<T> {
    pub get_property: Option<fn(&NativeClass, &Context, &T, &str) -> Option<Value>>,
    pub set_property: Option<fn(&NativeClass, &Context, &T, &str, &Value) -> bool>,
    pub has_property: Option<fn(&NativeClass, &Context, &T, &str) -> bool>,
    pub delete_property: Option<fn(&NativeClass, &Context, &T, &str) -> bool>,
    pub enumerate_properties: Option<fn(&NativeClass, &Context, &T) -> Option<Vec<String>>>,
}

pub const DEFAULT_VTABLE: JSCClassVTable = JSCClassVTable {
    get_property: None,
    set_property: None,
    has_property: None,
    delete_property: None,
    enumerate_properties: None,
    _jsc_reserved0: None,
    _jsc_reserved1: None,
    _jsc_reserved2: None,
    _jsc_reserved3: None,
};

#[macro_export]
macro_rules! js_vtable {
    (@foo $name:ident, (Some$body:tt)) => {};
    (@foo $name:ident, None) => {
        //TODO: handle the None case in vtable definition rather than generating a trampoline function
    };

    (@fnhandler $vtable:ident, $holder:ident, $name:ty, $fn_name:ident, $ret:ty, $glibber:expr) => {
        unsafe extern "C" fn $fn_name(class: *mut JSCClass, context: *mut JSCContext, instance: glib_sys::gpointer, name: *const i8) -> $ret {
            // TODO: if HANDLER.$fn_name.is_none() { ptr::null_mut() as _ }
            let rusted: Box<$name> = Box::from_raw(instance as _);
            let nameo: Option<String> = glib::translate::from_glib_none(name);
            let ret = $holder.$fn_name.unwrap()(&glib::translate::from_glib_borrow(class), &glib::translate::from_glib_borrow(context), &rusted, nameo.unwrap().as_str());
            ($glibber)(ret)
        }
        $vtable.$fn_name = Some($fn_name as _);
    };

    (@handler $vtable:ident, $holder:ident, $name:ty, get_property) => {
        js_vtable!(@fnhandler $vtable, $holder, $name, get_property, *mut JSCValue, |ret: Option<Value>| { ret.to_glib_none().0 });
    };
    (@handler $vtable:ident, $holder:ident, $name:ty, set_property) => {
        unsafe extern "C" fn set_property(class: *mut JSCClass, context: *mut JSCContext, instance: glib_sys::gpointer, name: *const i8, value: *mut JSCValue) -> glib_sys::gboolean {
            let rusted: Box<$name> = Box::from_raw(instance as _);
            let nameo: Option<String> = glib::translate::from_glib_none(name);
            let ret = $holder.set_property.unwrap()(&glib::translate::from_glib_borrow(class), &glib::translate::from_glib_borrow(context), &rusted, nameo.unwrap().as_str(), &glib::translate::from_glib_borrow(value));
            ret.to_glib()
        }
        $vtable.set_property = Some(set_property as _);
    };
    (@handler $vtable:ident, $holder:ident, $name:ty, enumerate_properties) => {
        unsafe extern "C" fn enumerate_properties(class: *mut JSCClass, context: *mut JSCContext, instance: glib_sys::gpointer) -> *mut *mut libc::c_char {
            let rusted: Box<$name> = Box::from_raw(instance as _);
            let maybe_v = $holder.enumerate_properties.unwrap()(&glib::translate::from_glib_borrow(class), &glib::translate::from_glib_borrow(context), &rusted);
            if maybe_v.is_none() { return std::ptr::null_mut(); }
            let mut vec = maybe_v.unwrap();
            let mut strs: Vec<*mut libc::c_char> = vec.iter().map(|item| {
                item.to_glib_full()
            }).collect();
            vec.shrink_to_fit();
            strs.push(std::ptr::null_mut());
            let ptr = strs.as_mut_ptr();
            std::mem::forget(strs);
            return ptr;
        }
        $vtable.enumerate_properties = Some(enumerate_properties as _);
    };
    (@handler $vtable:ident, $holder:ident, $name:ty, $fn_name:ident) => {
        js_vtable!(@fnhandler $vtable, $holder, $name, $fn_name, glib_sys::gboolean, |ret: bool| { ret.to_glib() });
    };

    (
        ClassVTable::<$name:ident>{
            $($handler:ident $(: $body:tt)*,)*
        }
    ) => {
        ({
            static HANDLER: ClassVTable<$name> = ClassVTable::<$name>{
                $($handler: $($body)*,)*
            };
            $( $( js_vtable!(@foo $handler, $body); )* )*

            const VTABLE: JSCClassVTable = JSCClassVTable{
                ..DEFAULT_VTABLE
            };
            $(js_vtable!(@handler VTABLE, HANDLER, $name, $handler);)*

            &VTABLE
        })
    };
}

/*pub struct ClassVTable(pub JSCClassVTable);

impl fmt::Display for ClassVTable {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(f, "Class")
    }
}*/

#[cfg(test)]
mod tests {
    use super::*;
    use ContextExtManual;

    struct Foo {}

    const MYVTABLE: &dyn AsNativeVTable<Foo> = js_vtable!(ClassVTable::<Foo> {
        get_property: (Some(|_, _, _, _| {
            Some(Value::new_undefined(&Context::get_current().unwrap()))
        })),
        set_property: None,
        has_property: None,
        delete_property: None,
        enumerate_properties: None,
    });

    #[test]
    fn subclass() {
        gtk::init().unwrap();
        let ctx = Context::new();
        ctx.register_class("Bar", Some(MYVTABLE));
    }
}
